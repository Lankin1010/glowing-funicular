#include <Wire.h>
#include "Olimex16x2.h"
#include <Servo.h>
#include <Arduino.h>

Olimex16x2 lcd(&Wire);
Servo myServo;

constexpr uint8_t BUTTON_30   = 0;
constexpr uint8_t BUTTON_1H   = 1;
constexpr uint8_t BUTTON_START = 2;
constexpr uint8_t BUTTON_RESET = 3;

constexpr int SERVO_PIN = 7;
constexpr int SERVO_IDLE = 90;
constexpr int SERVO_REVERSE = 0;

int totalSeconds = 0;
bool timerStarted = false;
bool postTimerMenu = false;
bool debugMode = false;

unsigned long lastTick = 0;
bool isRewinding = false;
unsigned long rewindStartTime = 0;
constexpr unsigned long rewindDuration = 6000;

unsigned long button3HoldStart = 0;
bool button3Held = false;

enum Mode { NONE, PLUS_30, PLUS_1H };
Mode lastUsedMode = NONE;
Mode currentPress = NONE;
bool modeSelected = false;

constexpr unsigned long inactiveTimeout = 5UL * 60UL * 1000UL; // 5 minutes
unsigned long lastActivityMillis = 0;
bool screenDimmed = false;

// Serial print interval in ms
constexpr unsigned long SERIAL_PRINT_INTERVAL = 3000;
unsigned long lastSerialPrint = 0;

// For serial command input
constexpr size_t SERIAL_BUF_SIZE = 32;
char serialBuffer[SERIAL_BUF_SIZE];
byte serialIndex = 0;

// Button debounce state
bool prevBtn30 = false, prevBtn1H = false, prevBtnStart = false, prevBtnReset = false;

// Helper: Minimal LCD line update (avoids flicker)
void lcdUpdateLine(uint8_t line, const char* text) {
  lcd.setCursor(0, line);
  lcd.print("                "); // clear line
  lcd.setCursor(0, line);
  lcd.print(text);
}

// Helper: Button read & debounce
bool debounceBtn(bool &prev, bool current) {
  bool pressed = (!prev && current);
  prev = current;
  return pressed;
}

// freeMemory stub for UNO R4
int freeMemory() { return -1; }

// ---- LCD/UI helpers ----
void showSetupScreen() {
  lcd.clear();
  lcdUpdateLine(0, "Set Timer:");
  updateTimerDisplay();
}

void updateTimerDisplay() {
  char buffer[17];
  int hours = totalSeconds / 3600;
  int minutes = (totalSeconds % 3600) / 60;
  if (hours > 0) snprintf(buffer, sizeof(buffer), "%dh %02dm", hours, minutes);
  else           snprintf(buffer, sizeof(buffer), "%2d min", minutes);
  lcdUpdateLine(1, buffer);
}

void updateCountdownDisplay() {
  char buffer[17];
  int hours = totalSeconds / 3600;
  int minutes = (totalSeconds % 3600) / 60;
  int seconds = totalSeconds % 60;
  if (hours > 0) snprintf(buffer, sizeof(buffer), "%dh %02dm %02ds", hours, minutes, seconds);
  else           snprintf(buffer, sizeof(buffer), "%02d:%02d remaining", minutes, seconds);
  lcdUpdateLine(1, buffer);
}

void showPostTimerMenu() {
  lcd.clear();
  lcdUpdateLine(0, "Btn2:Rewind");
  lcdUpdateLine(1, "Btn4:Reset");
}

// ---- State helpers ----
void resetTimerState() {
  totalSeconds = 0;
  timerStarted = false;
  postTimerMenu = false;
  debugMode = false;
  isRewinding = false;
  lastUsedMode = NONE;
  currentPress = NONE;
  modeSelected = false;

  myServo.write(SERVO_IDLE);
  if(myServo.attached()) myServo.detach();
  showSetupScreen();
  delay(500);
}

// ---- Smart selection for timer add ----
void handleSmartSelection(Mode buttonMode, int addSeconds, const char* label) {
  char msg[17];
  if (lastUsedMode == buttonMode || (modeSelected && currentPress == buttonMode)) {
    totalSeconds += addSeconds;
    snprintf(msg, sizeof(msg), "Added %s", label);
    lcdUpdateLine(1, msg);
    delay(800);
    updateTimerDisplay();
    lastUsedMode = buttonMode;
    modeSelected = false;
  } else {
    currentPress = buttonMode;
    modeSelected = true;
    lcdUpdateLine(1, label);
  }
}

// ---- Debug mode actions ----
void handleDebugMode(bool btn0, bool btn1, bool btn2, bool btn3) {
  if (debounceBtn(prevBtn30, btn0)) { totalSeconds += 10; updateCountdownDisplay(); }
  if (debounceBtn(prevBtn1H, btn1)) { totalSeconds += 60; updateCountdownDisplay(); }
  if (debounceBtn(prevBtnStart, btn2)) {
    if (!timerStarted && totalSeconds > 0) {
      timerStarted = true;
      lastTick = millis();
      lcd.clear();
      lcdUpdateLine(0, "Time left");
      updateCountdownDisplay();
    }
  }
  if (debounceBtn(prevBtnReset, btn3)) { resetTimerState(); }
}

// ---- Serial input handler ----
void handleSerialInput() {
  while (Serial.available()) {
    char c = Serial.read();
    if (c == '\n' || c == '\r') {
      if (serialIndex > 0) {
        serialBuffer[serialIndex] = 0;
        processSerialCommand(serialBuffer);
        serialIndex = 0;
      }
    } else if (serialIndex < SERIAL_BUF_SIZE - 1) {
      serialBuffer[serialIndex++] = c;
    } else {
      serialIndex = 0;
      Serial.println(F("Serial buffer overflow! Command too long."));
    }
  }
}

// ---- Serial command processor ----
void processSerialCommand(char* command) {
  if (strcasecmp(command, "help") == 0) {
    Serial.println(F("Commands:"));
    Serial.println(F("  status    - Show timer status"));
    Serial.println(F("  reset     - Reset timer and servo"));
    Serial.println(F("  start     - Start timer"));
    Serial.println(F("  add30     - Add 30 minutes"));
    Serial.println(F("  add1h     - Add 1 hour"));
    Serial.println(F("  debug     - Toggle debug mode"));
    Serial.println(F("  servo on  - Attach servo"));
    Serial.println(F("  servo off - Detach servo"));
    Serial.println(F("  pause     - Pause timer"));
    Serial.println(F("  resume    - Resume paused timer"));
    Serial.println(F("  time      - Show time left"));
    Serial.println(F("  add10     - Add 10 seconds"));
    Serial.println(F("  sub10     - Subtract 10 seconds"));
    Serial.println(F("  mem       - Show free memory"));
    Serial.println(F("  servo dance - Make servo dance"));
    Serial.println(F("  joke      - Tell a bad joke"));
    Serial.println(F("  beep      - Make beep sound (via serial)"));
    Serial.println(F("  flip      - Flip servo back and forth"));
  }
  else if (strcasecmp(command, "status") == 0) printSerialStatus(true, true, true, true);
  else if (strcasecmp(command, "reset") == 0) { resetTimerState(); Serial.println(F("Timer reset.")); }
  else if (strcasecmp(command, "start") == 0) {
    if (totalSeconds > 0) { timerStarted = true; lastTick = millis(); Serial.println(F("Timer started.")); }
    else Serial.println(F("Timer is zero, cannot start."));
  }
  else if (strcasecmp(command, "pause") == 0) {
    if (timerStarted) { timerStarted = false; Serial.println(F("Timer paused.")); }
    else Serial.println(F("Timer is not running."));
  }
  else if (strcasecmp(command, "resume") == 0) {
    if (!timerStarted && totalSeconds > 0) { timerStarted = true; lastTick = millis(); Serial.println(F("Timer resumed.")); }
    else if (timerStarted) Serial.println(F("Timer already running."));
    else Serial.println(F("No time to resume."));
  }
  else if (strcasecmp(command, "time") == 0) {
    int h = totalSeconds / 3600, m = (totalSeconds % 3600) / 60, s = totalSeconds % 60;
    Serial.print(F("Time left: "));
    if (h > 0) Serial.print(h), Serial.print(F("h "));
    Serial.print(m); Serial.print(F("m ")); Serial.print(s); Serial.println(F("s"));
  }
  else if (strcasecmp(command, "add10") == 0) { totalSeconds += 10; updateTimerDisplay(); Serial.println(F("Added 10 seconds.")); }
  else if (strcasecmp(command, "sub10") == 0) {
    if (totalSeconds > 10) { totalSeconds -= 10; updateTimerDisplay(); Serial.println(F("Subtracted 10 seconds.")); }
    else Serial.println(F("Cannot subtract, timer too low."));
  }
  else if (strcasecmp(command, "mem") == 0) {
    Serial.print(F("Free memory: ")); Serial.println(F("(not available on this board)"));
  }
  else if (strcasecmp(command, "servo dance") == 0) {
    Serial.println(F("Servo dance time!"));
    myServo.attach(SERVO_PIN);
    for (int i = 0; i < 3; i++) {
      myServo.write(0); delay(300); myServo.write(180); delay(300);
    }
    myServo.write(SERVO_IDLE); myServo.detach();
  }
  else if (strcasecmp(command, "joke") == 0) {
    Serial.println(F("Why don't programmers like nature?")); delay(1000);
    Serial.println(F("It has too many bugs."));
  }
  else if (strcasecmp(command, "beep") == 0) Serial.println(F("*beep beep beep*"));
  else if (strcasecmp(command, "flip") == 0) {
    Serial.println(F("Flipping servo back and forth!"));
    myServo.attach(SERVO_PIN);
    myServo.write(45); delay(400); myServo.write(135); delay(400); myServo.write(45); delay(400);
    myServo.write(SERVO_IDLE); myServo.detach();
  }
  else if (strcasecmp(command, "add30") == 0) { totalSeconds += 1800; updateTimerDisplay(); Serial.println(F("Added 30 minutes.")); }
  else if (strcasecmp(command, "add1h") == 0) { totalSeconds += 3600; updateTimerDisplay(); Serial.println(F("Added 1 hour.")); }
  else if (strcasecmp(command, "debug") == 0) { debugMode = !debugMode; Serial.print(F("Debug mode is now ")); Serial.println(debugMode ? "ON" : "OFF"); }
  else if (strcasecmp(command, "servo on") == 0) { myServo.attach(SERVO_PIN); myServo.write(SERVO_IDLE); Serial.println(F("Servo attached.")); }
  else if (strcasecmp(command, "servo off") == 0) { myServo.write(SERVO_IDLE); myServo.detach(); Serial.println(F("Servo detached.")); }
  else { Serial.print(F("Unknown command: ")); Serial.println(command); }
  Serial.println();
}

// ---- Serial status dump ----
void printSerialStatus(bool showButtons, bool showMode, bool showMemory, bool showTime) {
  Serial.println(F("\n=== Timer Status ==="));
  Serial.print(F("Timer Duration: ")); Serial.print(totalSeconds); Serial.println(F(" seconds"));
  Serial.print(F("Timer Running: ")); Serial.println(timerStarted ? "Yes" : "No");
  Serial.print(F("Post Timer Menu: ")); Serial.println(postTimerMenu ? "Yes" : "No");
  if (showMemory) {
    Serial.print(F("Free Memory: ")); Serial.println(F("(not available on this board)"));
  }
  if (showTime) {
    Serial.print(F("Millis uptime: ")); Serial.print(millis()); Serial.println(F(" ms"));
    Serial.print(F("Total ms counted: ")); Serial.print((unsigned long)totalSeconds * 1000UL); Serial.println(F(" ms"));
  }
  if (showButtons) {
    Serial.println(F("\nButton Assignments:"));
    Serial.println(F("  Btn0 = +30 min"));
    Serial.println(F("  Btn1 = +1 hour"));
    Serial.println(F("  Btn2 = Start timer"));
    Serial.println(F("  Btn3 = Reset timer / Toggle Debug (hold 3s)"));
  }
  Serial.println();
}

// ----------- SETUP -----------
void setup() {
  Serial.begin(9600);
  while (!Serial) delay(10);
  Wire.begin();
  lcd.begin();
  lcd.setBacklight(255);
  lcd.clear();
  showSetupScreen();

  myServo.attach(SERVO_PIN);
  myServo.write(SERVO_IDLE);
  delay(200);
  myServo.detach();

  lastActivityMillis = millis();

  Serial.println(F("=== Timer Initialized ==="));
  Serial.println(F("Type 'help' for commands."));
  Serial.println();
}

// ----------- LOOP -----------
void loop() {
  unsigned long now = millis();

  handleSerialInput();

  bool btn30   = lcd.readButton(BUTTON_30);
  bool btn1H   = lcd.readButton(BUTTON_1H);
  bool btnStart= lcd.readButton(BUTTON_START);
  bool btnReset= lcd.readButton(BUTTON_RESET);

  // Reset inactivity timer & wake screen on any button press
  if (btn30 || btn1H || btnStart || btnReset) {
    lastActivityMillis = now;
    if (screenDimmed) {
      screenDimmed = false;
      lcd.setBacklight(255);
      delay(200); // prevent immediate button actions on wake
      return;
    }
  }

  // Dim screen if inactive for 5 minutes
  if (!screenDimmed && (now - lastActivityMillis > inactiveTimeout)) {
    screenDimmed = true;
    lcd.setBacklight(20);
  }

  // Handle debug toggle (button 3 hold for 3s)
  if (btnReset) {
    if (!button3Held) {
      button3HoldStart = now;
      button3Held = true;
    } else if (now - button3HoldStart >= 3000) {
      debugMode = !debugMode;
      button3Held = false;
      if (debugMode) {
        lcd.clear();
        lcdUpdateLine(0, "Debug mode ON");
        lcdUpdateLine(1, "Btns:0R 1E 2S 3Rst");
        delay(1000);
      } else {
        showSetupScreen();
        delay(500);
      }
    }
  } else {
    button3Held = false;
  }

  if (debugMode) {
    handleDebugMode(btn30, btn1H, btnStart, btnReset);
    if (now - lastSerialPrint >= 1000) {
      printSerialStatus(true, true, true, true);
      lastSerialPrint = now;
    }
    return;
  }

  // Timer setup mode
  if (!timerStarted && !postTimerMenu) {
    if (debounceBtn(prevBtn30, btn30))   handleSmartSelection(PLUS_30, 30 * 60, "+30 min");
    if (debounceBtn(prevBtn1H, btn1H))   handleSmartSelection(PLUS_1H, 60 * 60, "+1 hour");
    if (debounceBtn(prevBtnStart, btnStart) && totalSeconds > 0) {
      timerStarted = true;
      lastTick = now;
      lcd.clear();
      lcdUpdateLine(0, "Time left");
      updateCountdownDisplay();
    }
  }

  // Timer running
  if (timerStarted) {
    if ((now - lastTick) >= 1000) {
      lastTick = now;
      if (totalSeconds > 0) {
        totalSeconds--;
        updateCountdownDisplay();
        Serial.print(F("Tick: "));
        Serial.println(totalSeconds);
      } else {
        timerStarted = false;
        isRewinding = true;
        rewindStartTime = now;
        lcd.clear();
        lcdUpdateLine(0, "Rewinding...");
        myServo.attach(SERVO_PIN);
        myServo.write(SERVO_REVERSE);
      }
    }
    if (debounceBtn(prevBtnReset, btnReset)) {
      resetTimerState();
    }
  }

  // Rewinding
  if (isRewinding && now - rewindStartTime >= rewindDuration) {
    isRewinding = false;
    myServo.write(SERVO_IDLE);
    delay(200);
    myServo.detach();
    postTimerMenu = true;
    showPostTimerMenu();
  }

  // Post timer menu
  if (postTimerMenu) {
    if (btn1H) {
      if (!myServo.attached()) myServo.attach(SERVO_PIN);
      myServo.write(SERVO_REVERSE);
    } else {
      if (myServo.attached()) {
        myServo.write(SERVO_IDLE);
        myServo.detach();
      }
    }
    if (debounceBtn(prevBtnReset, btnReset)) {
      if (myServo.attached()) {
        myServo.write(SERVO_IDLE);
        myServo.detach();
      }
      resetTimerState();
      delay(100);
      NVIC_SystemReset();
    }
  }

  // Print serial debug info every SERIAL_PRINT_INTERVAL ms
  if (now - lastSerialPrint >= SERIAL_PRINT_INTERVAL) {
    printSerialStatus(true, true, true, true);
    lastSerialPrint = now;
  }
}
