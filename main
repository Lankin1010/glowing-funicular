#include <Wire.h>
#include "Olimex16x2.h"
#include <Servo.h>
#include <Arduino.h>
// #include <stdlib.h> // Not needed unless you use malloc/free
// #include <stdio.h>  // Not needed unless you use printf/sprintf
// #include <malloc.h> // Not needed unless you specifically use mallinfo

Olimex16x2 lcd(&Wire);
Servo myServo;

const uint8_t BUTTON_30 = 0;
const uint8_t BUTTON_1H = 1;
const uint8_t BUTTON_START = 2;
const uint8_t BUTTON_RESET = 3;

const int SERVO_PIN = 7;
const int SERVO_IDLE = 90;
const int SERVO_REVERSE = 0;

int totalSeconds = 0;
bool timerStarted = false;
bool postTimerMenu = false;
bool debugMode = false;

unsigned long lastTick = 0;
bool isRewinding = false;
unsigned long rewindStartTime = 0;
const unsigned long rewindDuration = 6000;

unsigned long button3HoldStart = 0;
bool button3Held = false;

enum Mode { NONE, PLUS_30, PLUS_1H };
Mode lastUsedMode = NONE;
Mode currentPress = NONE;
bool modeSelected = false;

unsigned long lastInactiveMillis = 0;
const unsigned long inactiveTimeout = 5UL * 60UL * 1000UL; // 5 minutes
bool screenDimmed = false;
unsigned long lastActivityMillis = 0;

// Serial print interval in ms
const unsigned long SERIAL_PRINT_INTERVAL = 3000;
unsigned long lastSerialPrint = 0;

// For serial command input
#define SERIAL_BUF_SIZE 32
char serialBuffer[SERIAL_BUF_SIZE];
byte serialIndex = 0;

/*
 * freeMemory is platform-specificâ€”remove or replace with a simpler implementation
 * if mallinfo() is not available on your Arduino platform.
 */
int freeMemory() {
  #if defined(__arm__) && defined(__SAM3X8E__)
    struct mallinfo mi = mallinfo();
    return mi.fordblks;
  #else
    // On AVR, use stack-pointer arithmetic or a library for free memory.
    extern int __heap_start, *__brkval; 
    int v; 
    return (int) &v - (__brkval == 0 ? (int) &__heap_start : (int) __brkval); 
  #endif
}

void setup() {
  Serial.begin(9600);
  while (!Serial) delay(10);

  Wire.begin();
  lcd.begin();
  lcd.setBacklight(255);
  lcd.clear();
  showSetupScreen();

  myServo.attach(SERVO_PIN);
  myServo.write(SERVO_IDLE);
  delay(200);
  myServo.detach();

  lastActivityMillis = millis();

  Serial.println(F("=== Timer Initialized ==="));
  Serial.println(F("Type 'help' for commands."));
  Serial.println();
}

void loop() {
  unsigned long now = millis();

  handleSerialInput();

  bool btn30 = lcd.readButton(BUTTON_30);
  bool btn1H = lcd.readButton(BUTTON_1H);
  bool btnStart = lcd.readButton(BUTTON_START);
  bool btnReset = lcd.readButton(BUTTON_RESET);

  // Reset inactivity timer & wake screen on any button press
  if (btn30 || btn1H || btnStart || btnReset) {
    lastActivityMillis = now;
    if (screenDimmed) {
      screenDimmed = false;
      lcd.setBacklight(255);
      delay(200); // prevent immediate button actions on wake
      return;
    }
  }

  // Dim screen if inactive for 5 minutes
  if (!screenDimmed && (now - lastActivityMillis > inactiveTimeout)) {
    screenDimmed = true;
    lcd.setBacklight(20);
  }

  // Handle debug toggle (button 3 hold for 3s)
  if (btnReset) {
    if (!button3Held) {
      button3HoldStart = now;
      button3Held = true;
    } else if (now - button3HoldStart >= 3000) {
      debugMode = !debugMode;
      button3Held = false;
      if (debugMode) {
        lcd.clear();
        lcd.drawLine(0, "Debug mode ON");
        lcd.drawLine(1, "Btns:0R 1E 2S 3Rst");
        delay(1000);
      } else {
        showSetupScreen();
        delay(500);
      }
    }
  } else {
    button3Held = false;
  }

  if (debugMode) {
    handleDebugMode(btn30, btn1H, btnStart, btnReset);
    // Also print debug info faster in debug mode
    if (now - lastSerialPrint >= 1000) {
      printSerialStatus(true, true, true, true);
      lastSerialPrint = now;
    }
    return;
  }

  if (!timerStarted && !postTimerMenu) {
    if (btn30) {
      handleSmartSelection(PLUS_30, 30 * 60, "+30 min");
      delay(300);
    }
    if (btn1H) {
      handleSmartSelection(PLUS_1H, 60 * 60, "+1 hour");
      delay(300);
    }
    if (btnStart && totalSeconds > 0) {
      timerStarted = true;
      lastTick = now;
      lcd.clear();
      lcd.drawLine(0, "Time left");
      updateCountdownDisplay();
      delay(300);
    }
  }

  if (timerStarted) {
    if ((unsigned long)(now - lastTick) >= 1000) {
      lastTick = now;
      if (totalSeconds > 0) {
        totalSeconds--;
        updateCountdownDisplay();
        // Serial debug for timer tick:
        Serial.print(F("Tick: "));
        Serial.println(totalSeconds);
      } else {
        timerStarted = false;
        isRewinding = true;
        rewindStartTime = now;
        lcd.clear();
        lcd.drawLine(0, "Rewinding...");
        myServo.attach(SERVO_PIN);
        myServo.write(SERVO_REVERSE);
      }
    }

    if (btnReset) {
      resetTimerState();
      delay(300);
    }
  }

  if (isRewinding && now - rewindStartTime >= rewindDuration) {
    isRewinding = false;
    myServo.write(SERVO_IDLE);
    delay(200);
    myServo.detach();

    postTimerMenu = true;
    showPostTimerMenu();
  }

  if (postTimerMenu) {
    if (btn1H) {
      if (!myServo.attached()) myServo.attach(SERVO_PIN);
      myServo.write(SERVO_REVERSE);
    } else {
      if (myServo.attached()) {
        myServo.write(SERVO_IDLE);
        myServo.detach();
      }
    }

    if (btnReset) {
      if (myServo.attached()) {
        myServo.write(SERVO_IDLE);
        myServo.detach();
      }
      resetTimerState();
      delay(100);
      NVIC_SystemReset();
    }
  }

  // Print serial debug info every SERIAL_PRINT_INTERVAL ms
  if (now - lastSerialPrint >= SERIAL_PRINT_INTERVAL) {
    printSerialStatus(true, true, true, true);
    lastSerialPrint = now;
  }
}

void handleSmartSelection(Mode buttonMode, int addSeconds, const char* label) {
  if (lastUsedMode == buttonMode) {
    totalSeconds += addSeconds;
    lcd.clearLine(1);
    char msg[17];
    snprintf(msg, sizeof(msg), "Added %s", label);
    lcd.drawLine(1, msg);
    delay(800);
    updateTimerDisplay();
    modeSelected = false;
  } else if (modeSelected && currentPress == buttonMode) {
    totalSeconds += addSeconds;
    lcd.clearLine(1);
    char msg[17];
    snprintf(msg, sizeof(msg), "Added %s", label);
    lcd.drawLine(1, msg);
    lastUsedMode = buttonMode;
    delay(800);
    updateTimerDisplay();
    modeSelected = false;
  } else {
    currentPress = buttonMode;
    modeSelected = true;
    lcd.clearLine(1);
    lcd.drawLine(1, label);
  }
}

void showSetupScreen() {
  lcd.clear();
  lcd.drawLine(0, "Set Timer:");
  updateTimerDisplay();
}

void updateTimerDisplay() {
  lcd.clearLine(1);
  int hours = totalSeconds / 3600;
  int minutes = (totalSeconds % 3600) / 60;
  char buffer[17];
  if (hours > 0) {
    snprintf(buffer, sizeof(buffer), "%dh %02dm", hours, minutes);
  } else {
    snprintf(buffer, sizeof(buffer), "%2d min", minutes);
  }
  lcd.drawLine(1, buffer);
}

void updateCountdownDisplay() {
  lcd.clearLine(1);
  int hours = totalSeconds / 3600;
  int minutes = (totalSeconds % 3600) / 60;
  int seconds = totalSeconds % 60;
  char buffer[17];
  if (hours > 0) {
    snprintf(buffer, sizeof(buffer), "%dh %02dm %02ds", hours, minutes, seconds);
  } else {
    snprintf(buffer, sizeof(buffer), "%02d:%02d remaining", minutes, seconds);
  }
  lcd.drawLine(1, buffer);
}

void showPostTimerMenu() {
  lcd.clear();
  lcd.drawLine(0, "Btn2:Rewind");
  lcd.drawLine(1, "Btn4:Reset");
}

void resetTimerState() {
  totalSeconds = 0;
  timerStarted = false;
  postTimerMenu = false;
  debugMode = false;
  isRewinding = false;
  lastUsedMode = NONE;
  currentPress = NONE;
  modeSelected = false;

  myServo.write(SERVO_IDLE);
  myServo.detach();
  showSetupScreen();
  delay(500);
}

void handleDebugMode(bool btn0, bool btn1, bool btn2, bool btn3) {
  if (btn0) {
    totalSeconds += 10; // add 10 seconds quickly in debug
    updateCountdownDisplay();
    delay(150);
  }
  if (btn1) {
    totalSeconds += 60; // add 1 minute quickly in debug
    updateCountdownDisplay();
    delay(150);
  }
  if (btn2) {
    if (!timerStarted && totalSeconds > 0) {
      timerStarted = true;
      lastTick = millis();
      lcd.clear();
      lcd.drawLine(0, "Time left");
      updateCountdownDisplay();
    }
    delay(150);
  }
  if (btn3) {
    resetTimerState();
    delay(300);
  }
}

/*
 * Improved serial input handler with buffer overflow protection.
 */
void handleSerialInput() {
  while (Serial.available()) {
    char c = Serial.read();
    if (c == '\n' || c == '\r') {
      if (serialIndex > 0) {
        serialBuffer[serialIndex] = 0;
        processSerialCommand(serialBuffer);
        serialIndex = 0;
      }
    } else if (serialIndex < SERIAL_BUF_SIZE - 1) {
      serialBuffer[serialIndex++] = c;
    } else {
      // Buffer overflow, reset and warn
      serialIndex = 0;
      Serial.println(F("Serial buffer overflow! Command too long."));
    }
  }
}

void processSerialCommand(char* command) {
  if (strcasecmp(command, "help") == 0) {
    Serial.println(F("Commands:"));
    Serial.println(F("  status    - Show timer status"));
    Serial.println(F("  reset     - Reset timer and servo"));
    Serial.println(F("  start     - Start timer"));
    Serial.println(F("  add30     - Add 30 minutes"));
    Serial.println(F("  add1h     - Add 1 hour"));
    Serial.println(F("  debug     - Toggle debug mode"));
    Serial.println(F("  servo on  - Attach servo"));
    Serial.println(F("  servo off - Detach servo"));

    // New useful commands
    Serial.println(F("  pause     - Pause timer"));
    Serial.println(F("  resume    - Resume paused timer"));
    Serial.println(F("  time      - Show time left"));
    Serial.println(F("  add10     - Add 10 seconds"));
    Serial.println(F("  sub10     - Subtract 10 seconds"));
    Serial.println(F("  mem       - Show free memory"));

    // Funny commands
    Serial.println(F("  servo dance - Make servo dance"));
    Serial.println(F("  joke      - Tell a bad joke"));
    Serial.println(F("  beep      - Make beep sound (via serial)"));
    Serial.println(F("  flip      - Flip servo back and forth"));

  } 
  else if (strcasecmp(command, "status") == 0) {
    printSerialStatus(true, true, true, true);
  }
  else if (strcasecmp(command, "reset") == 0) {
    resetTimerState();
    Serial.println(F("Timer reset."));
  }
  else if (strcasecmp(command, "start") == 0) {
    if (totalSeconds > 0) {
      timerStarted = true;
      lastTick = millis();
      Serial.println(F("Timer started."));
    } else {
      Serial.println(F("Timer is zero, cannot start."));
    }
  }
  else if (strcasecmp(command, "pause") == 0) {
    if (timerStarted) {
      timerStarted = false;
      Serial.println(F("Timer paused."));
    } else {
      Serial.println(F("Timer is not running."));
    }
  }
  else if (strcasecmp(command, "resume") == 0) {
    if (!timerStarted && totalSeconds > 0) {
      timerStarted = true;
      lastTick = millis();
      Serial.println(F("Timer resumed."));
    } else if (timerStarted) {
      Serial.println(F("Timer already running."));
    } else {
      Serial.println(F("No time to resume."));
    }
  }
  else if (strcasecmp(command, "time") == 0) {
    int h = totalSeconds / 3600;
    int m = (totalSeconds % 3600) / 60;
    int s = totalSeconds % 60;
    Serial.print(F("Time left: "));
    if (h > 0) Serial.print(h), Serial.print(F("h "));
    Serial.print(m);
    Serial.print(F("m "));
    Serial.print(s);
    Serial.println(F("s"));
  }
  else if (strcasecmp(command, "add10") == 0) {
    totalSeconds += 10;
    updateTimerDisplay();
    Serial.println(F("Added 10 seconds."));
  }
  else if (strcasecmp(command, "sub10") == 0) {
    if (totalSeconds > 10) {
      totalSeconds -= 10;
      updateTimerDisplay();
      Serial.println(F("Subtracted 10 seconds."));
    } else {
      Serial.println(F("Cannot subtract, timer too low."));
    }
  }
  else if (strcasecmp(command, "mem") == 0) {
    Serial.print(F("Free memory: "));
    Serial.print(freeMemory());
    Serial.println(F(" bytes"));
  }
  else if (strcasecmp(command, "servo dance") == 0) {
    Serial.println(F("Servo dance time!"));
    myServo.attach(SERVO_PIN);
    for (int i = 0; i < 3; i++) {
      myServo.write(0);
      delay(300);
      myServo.write(180);
      delay(300);
    }
    myServo.write(SERVO_IDLE);
    myServo.detach();
  }
  else if (strcasecmp(command, "joke") == 0) {
    Serial.println(F("Why don't programmers like nature?"));
    delay(1000);
    Serial.println(F("It has too many bugs."));
  }
  else if (strcasecmp(command, "beep") == 0) {
    Serial.println(F("*beep beep beep*"));
  }
  else if (strcasecmp(command, "flip") == 0) {
    Serial.println(F("Flipping servo back and forth!"));
    myServo.attach(SERVO_PIN);
    myServo.write(45);
    delay(400);
    myServo.write(135);
    delay(400);
    myServo.write(45);
    delay(400);
    myServo.write(SERVO_IDLE);
    myServo.detach();
  }
  else if (strcasecmp(command, "add30") == 0) {
    totalSeconds += 1800;
    updateTimerDisplay();
    Serial.println(F("Added 30 minutes."));
  }
  else if (strcasecmp(command, "add1h") == 0) {
    totalSeconds += 3600;
    updateTimerDisplay();
    Serial.println(F("Added 1 hour."));
  }
  else if (strcasecmp(command, "debug") == 0) {
    debugMode = !debugMode;
    Serial.print(F("Debug mode is now "));
    Serial.println(debugMode ? "ON" : "OFF");
  }
  else if (strcasecmp(command, "servo on") == 0) {
    myServo.attach(SERVO_PIN);
    myServo.write(SERVO_IDLE);
    Serial.println(F("Servo attached."));
  }
  else if (strcasecmp(command, "servo off") == 0) {
    myServo.write(SERVO_IDLE);
    myServo.detach();
    Serial.println(F("Servo detached."));
  }
  else {
    Serial.print(F("Unknown command: "));
    Serial.println(command);
  }
  Serial.println();
}


void printSerialStatus(bool showButtons, bool showMode, bool showMemory, bool showTime) {
  Serial.println(F("\n=== Timer Status ==="));
  
  Serial.print(F("Timer Duration: "));
  Serial.print(totalSeconds);
  Serial.println(F(" seconds"));

  Serial.print(F("Timer Running: "));
  Serial.println(timerStarted ? "Yes" : "No");

  Serial.print(F("Post Timer Menu: "));
  Serial.println(postTimerMenu ? "Yes" : "No");

  if (showMemory) {
    Serial.print(F("Free Memory: "));
    Serial.print(freeMemory());
    Serial.println(F(" bytes"));
  }

  if (showTime) {
    Serial.print(F("Millis uptime: "));
    Serial.print(millis());
    Serial.println(F(" ms"));

    Serial.print(F("Total ms counted: "));
    Serial.print((unsigned long)totalSeconds * 1000UL);
    Serial.println(F(" ms"));
  }

  if (showButtons) {
    Serial.println(F("\nButton Assignments:"));
    Serial.println(F("  Btn0 = +30 min"));
    Serial.println(F("  Btn1 = +1 hour"));
    Serial.println(F("  Btn2 = Start timer"));
    Serial.println(F("  Btn3 = Reset timer / Toggle Debug (hold 3s)"));
  }
  
  Serial.println();
}
